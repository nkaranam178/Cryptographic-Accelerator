
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module capstone(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW,
	
	//output			 [127:0]	ciphertext,
	output						cpu_done
);



//=======================================================
//  REG/WIRE declarations
//=======================================================




//=======================================================
//  Structural coding
//=======================================================

/*
wire[15:0] read_data_1, read_data_2, imm, memwb_data, exmem_data, alu_out, value_to_write;
wire[4:0] opcode;
wire[2:0] flags;
wire[1:0] aluOp;
wire aluSrc;

execute ex(.clk(CLOCK_50), .rst_n(SW[0]), .read_data_1(read_data_1), .read_data_2(read_data_2), 
	.imm(imm), .opcode(opcode), .aluOp(aluOp), .aluSrc(aluSrc), .memwb_data(memwb_data), 
	.exmem_data(exmem_data), .flags(flags), .alu_out(alu_out), .value_to_write(value_to_write));
*/

/*
wire regWrite;
wire[2:0] rs,rt,rd;	// register number
wire[15:0] write_data;
wire[15:0] read_data_1, read_data_2;

regFile rf(.clk(CLOCK_50), .rst_n(SW[0]), .regWrite(regWrite), .rs(rs), .rt(rt),
	.rd(rd), .write_data(write_data), .read_data_1(read_data_1), .read_data_2(read_data_2));


wire[4:0] opcode;
wire Branch, MemWrite, MemToReg, RegWrite, ALUSrc, H_int, E_int, D_int;

control c(.clk(CLOCK_50), .rst_n(SW[0]), .opcode(opcode), .Branch(Branch),
	.MemWrite(MemWrite), .MemToReg(MemToReg), .RegWrite(RegWrite), .ALUSrc(ALUSrc),
	.H_int(H_int), .E_int(E_int), .D_int(D_int));
	
wire[15:0] alu_out, alu_in2, mem_out;
wire memRead, DmemWrite;
	
Mem m1(.clk(CLOCK2_50), .rst_n(SW[0]), .alu_out(alu_out), .alu_in2(alu_in2),
	.memRead(memRead), .DmemWrite(DmemWrite), .mem_out(mem_out));
	
Mem m2(.clk(CLOCK2_50), .rst_n(SW[1]), .alu_out(alu_out), .alu_in2(alu_in2),
	.memRead(memRead), .DmemWrite(DmemWrite), .mem_out(mem_out));
	
Mem m3(.clk(CLOCK2_50), .rst_n(SW[2]), .alu_out(alu_out), .alu_in2(alu_in2),
	.memRead(memRead), .DmemWrite(DmemWrite), .mem_out(mem_out));

Mem m4(.clk(CLOCK2_50), .rst_n(SW[3]), .alu_out(alu_out), .alu_in2(alu_in2),
	.memRead(memRead), .DmemWrite(DmemWrite), .mem_out(mem_out));
	
Mem m5(.clk(CLOCK2_50), .rst_n(SW[4]), .alu_out(alu_out), .alu_in2(alu_in2),
	.memRead(memRead), .DmemWrite(DmemWrite), .mem_out(mem_out));
	
Mem m6(.clk(CLOCK2_50), .rst_n(SW[5]), .alu_out(alu_out), .alu_in2(alu_in2),
	.memRead(memRead), .DmemWrite(DmemWrite), .mem_out(mem_out));

*/

/*
	 wire clk; 
	 wire rst_n;
	 wire H_int;
	 wire [10:0] index;
	 wire [511:0] hash_data;
	 wire H_done;
	 wire [10:0] hash_address;
	 wire [159:0] hh;
	//TEST INPUTS
	 wire bram_done;
	// ext_done;
	 wire rounds_done;
	 wire spart_done;
	//TEST OUTPUTS
	 wire[7:0] msg_cnt;
	 wire ext_en;
	 wire rst_ext;
	 wire rounds_en;
	 wire rst_rounds;
	
	
hash_block h(.clk(CLOCK_50), .rst_n(SW[0]), .H_int(SW[1]), .index(index), .hash_data(hash_data),
	.H_done(H_done), .hash_address(hash_address), .hh(hh), .bram_done(bram_done), 
	.rounds_done(rounds_done), .spart_done(spart_done), .msg_cnt(msg_cnt), .ext_en(ext_en),
	.rst_ext(rst_ext), .rounds_en(rounds_en), .rst_rounds(rst_rounds));
*/
/*
	wire cpu_start; // tell cpu to begin excecution, read next instruction in from program loader
	wire [15:0] to_IMEM;	// dataline that gets written into IMEM BRAM, addr to read from program loader
	wire [511:0] to_HASH; // dataline that gets written into HASH BRAM
	wire [127:0] to_ENC, to_DEC; //datalines that get written into ENC and DEC BRAM

Spart_Control_TL spart(.clk(CLOCK2_50), .rst_n(SW[0]), .to_IMEM(to_IMEM),
	.to_HASH(to_HASH), .to_DEC(to_DEC), .to_ENC(to_ENC), .cpu_start(cpu_start));
*/	
	
		// GENERAL/GLOBAL //
	wire cpu_start;
	// IMEM //
	wire imem_en;
	wire[8:0] imem_addr;
	wire[15:0] imem_d;
	wire[15:0] imem_q;
	// HASH_MEM //
	wire	[3:0] hash_address_a, hash_addr_a_final;
	wire	[3:0] hash_address_b, hash_addr_b_final;
	wire	[255:0] hash_data_a;
	wire	[255:0] hash_data_b;
	wire hash_en;
	wire [255:0] hash_q_a;
	wire [255:0] hash_q_b;
	// ENCRYPT_MEM //
	wire	[4:0] encrypt_addr, encrypt_addr_final;
	wire	[127:0] encrypt_d;
	wire encrypt_en;
	wire [127:0] encrypt_q;
	// DECRYPTMEM //
	wire	[4:0] decrypt_addr, decrypt_addr_final;
	wire	[127:0] decrypt_d;
	wire decrypt_en;
	wire [127:0] decrypt_q;
	
	Spart_Control_TL sc(.clk(CLOCK_50), 
		.rst_n(SW[0]), 
		.to_IMEM(imem_d), 
		.to_HASH_a(hash_data_a), 
		.to_HASH_b(hash_data_b), 
		.to_DEC(decrypt_d), 
		.to_ENC(encrypt_d), 
		.cpu_start(cpu_start),
		.to_IMEM_en(imem_en), 
		.to_HASH_en_TL(hash_en), 
		.to_DEC_en(decrypt_en), 
		.to_ENC_en(encrypt_en), 
		.imem_addr(imem_addr), 
		.hash_addr_a(hash_address_a),
		.hash_addr_b(hash_address_b), 
		.encrypt_addr(encrypt_addr), 
		.decrypt_addr(decrypt_addr));
	
	
   wire [15:0] PC;
   wire [15:0] Instr;           
                               
   wire        RegWrite;       /* Whether register file is being written to */
   wire [2:0]  Rd;  	       /* What register is written */
   wire [15:0] WriteData;      /* Data */
   wire        MemWrite;       /* Similar as above but for memory */
   wire        MemRead;
   wire [15:0] MemAddress;
   wire [15:0] MemData;
   wire [10:0] mem_index;

   wire        Halt;         /* Halt executed and in writeback stage */

   
   reg writeToFile;
   
   wire H_done, E_done, D_done, side_channel_done_ff;
   wire H_int, E_int, D_int;
   wire[127:0] plaintext;
   
   wire[127:0] key;
   assign key = 128'h000102030405060708090a0b0c0d0e0f;

     
   // General purpose cpu instance
   gp_cpu cpu(.clk(CLOCK_50), .rst_n(cpu_start), .H_done(H_done), .E_done(E_done),
		.ImemWrite(imem_en), .ImemData(imem_d), .writeToFile(writeToFile), .D_done(D_done), 
		.H_int(H_int), .E_int(E_int), .D_int(D_int), .index(mem_index), .cpu_done(cpu_done),
		.addr_to_write(imem_addr), .side_channel_done_ff(side_channel_done_ff));
		
	// 2 phase SPART
	assign decrypt_addr_final = cpu_start ? mem_index[4:0] : decrypt_addr;
		
	ram128_32 decrypt_mem(
		.address(decrypt_addr_final),
		.clock(CLOCK_50),
		.data(decrypt_d),
		.wren(decrypt_en),
		.q(decrypt_q));
		
	Decrypt_TopLevel dec(.clk(CLOCK_50), .rst_n(SW[0]), .D_int(D_int & ~side_channel_done_ff & ~D_done),
		.ciphertext(decrypt_q), .key(key), .plaintext(plaintext), .D_done(D_done));
	
	// 2 phase SPART
	assign encrypt_addr_final = cpu_start ? mem_index[4:0] : encrypt_addr;
	
	ram128_32 encrypt_mem(
		.address(encrypt_addr_final),
		.clock(CLOCK_50),
		.data(encrypt_d),
		.wren(encrypt_en),
		.q(encrypt_q));
		
	Encrypt_TopLevel enc(.clk(CLOCK_50), .rst_n(SW[0]), .E_int(E_int & ~side_channel_done_ff & ~E_done),
		.plaintext(encrypt_q), .key(key), .ciphertext(ciphertext), .E_done(E_done));
		
		
	wire bram_done, spart_done, rounds_done;
	wire[7:0] msg_cnt;
	wire [159:0]	hh;
//	wire [511:0] hash_data;
	wire[3:0] hash_block_addr_a, hash_block_addr_b;
//	wire wren_a, wren_b;
	wire [255:0] data_a, data_b;
	wire ext_en, rst_ext, rounds_en, rst_rounds;
	
	// 2 phase SPART
	assign hash_addr_a_final = cpu_start ? hash_block_addr_a : hash_address_a;
	assign hash_addr_b_final = cpu_start ? hash_block_addr_b : hash_address_b;
	
	hash_block hash_block0(	.clk(CLOCK_50),
							.rst_n(SW[0]),
							.H_int(H_int & ~side_channel_done_ff & ~H_done),
							.index(mem_index[3:0]),
							//.hash_data(hash_data),
							.H_done(H_done),
							//.hash_address(hash_address),
							.hh(hh),
							//.bram_done( bram_done),
							//.ext_done(ext_done),
							.rounds_done(rounds_done),
							.spart_done(spart_done),
							.ext_en(ext_en),
							.rst_ext(rst_ext), 
							.rounds_en(rounds_en), 
							.rst_rounds(rst_rounds),
							.msg_cnt(msg_cnt),
							.q_a(hash_q_a),
							.q_b(hash_q_b),
							.address_a(hash_block_addr_a),
							.address_b(hash_block_addr_b),
							.wren_a(),
							.wren_b());
							
	ram256x2_16 bigram(
						.address_a(hash_addr_a_final),
						.address_b(hash_addr_b_final),
						.clock(CLOCK_50),
						.data_a(hash_data_a),
						.data_b(hash_data_b),
						.wren_a(hash_en),
						.wren_b(hash_en),
						.q_a(hash_q_a),
						.q_b(hash_q_b));


endmodule
